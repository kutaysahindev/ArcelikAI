"use strict";

exports.run = run;

var _interact = require("./interact");

var _introspect = require("./introspect");

var _remediate = require("./remediate");

var _flow = require("./flow");

var remediators = _interopRequireWildcard(require("./remediators"));

var _types = require("../types");

var _idxJs = require("./types/idx-js");

var _transactionMeta = require("./transactionMeta");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/*!
 * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
 * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
 *
 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * 
 * See the License for the specific language governing permissions and limitations under the License.
 */

/* eslint-disable max-statements, complexity, max-depth */
function getEnabledFeatures(idxResponse) {
  const res = [];
  const {
    actions,
    neededToProceed
  } = idxResponse;

  if (actions['currentAuthenticator-recover']) {
    res.push(_types.IdxFeature.PASSWORD_RECOVERY);
  }

  if (neededToProceed.some(({
    name
  }) => name === 'select-enroll-profile')) {
    res.push(_types.IdxFeature.REGISTRATION);
  }

  if (neededToProceed.some(({
    name
  }) => name === 'redirect-idp')) {
    res.push(_types.IdxFeature.SOCIAL_IDP);
  }

  return res;
}

function getAvailableSteps(idxResponse) {
  const res = [];
  const remediatorMap = Object.values(remediators).reduce((map, remediatorClass) => {
    // Only add concrete subclasses to the map
    if (remediatorClass.remediationName) {
      map[remediatorClass.remediationName] = remediatorClass;
    }

    return map;
  }, {});

  for (let remediation of idxResponse.neededToProceed) {
    const T = remediatorMap[remediation.name];

    if (T) {
      const remediator = new T(remediation);
      res.push(remediator.getNextStep(idxResponse.context));
    }
  }

  return res;
}

async function run(authClient, options = {}) {
  let tokens;
  let nextStep;
  let messages;
  let error;
  let meta;
  let enabledFeatures;
  let availableSteps;
  let status = _types.IdxStatus.PENDING;
  let shouldClearTransaction = false;
  let clearSharedStorage = true;
  let idxResponse;
  let interactionHandle;
  let metaFromResp;
  let interactionCode;

  try {
    var _metaFromResp;

    let {
      flow,
      state,
      scopes,
      version,
      remediators,
      actions,
      withCredentials,
      exchangeCodeForTokens,
      autoRemediate,
      step
    } = options; // Only one flow can be operating at a time

    flow = flow || authClient.idx.getFlow() || 'default';

    if (flow) {
      authClient.idx.setFlow(flow);
      const flowSpec = (0, _flow.getFlowSpecification)(authClient, flow); // Favor option values over flow spec

      withCredentials = typeof withCredentials !== 'undefined' ? withCredentials : flowSpec.withCredentials;
      remediators = remediators || flowSpec.remediators;
      actions = actions || flowSpec.actions;
    } // Try to resume saved transaction


    metaFromResp = (0, _transactionMeta.getSavedTransactionMeta)(authClient, {
      state
    });
    interactionHandle = (_metaFromResp = metaFromResp) === null || _metaFromResp === void 0 ? void 0 : _metaFromResp.interactionHandle; // may be undefined

    if (!interactionHandle) {
      // start a new transaction
      authClient.transactionManager.clear();
      const interactResponse = await (0, _interact.interact)(authClient, {
        withCredentials,
        state,
        scopes
      });
      interactionHandle = interactResponse.interactionHandle;
      metaFromResp = interactResponse.meta;
      withCredentials = metaFromResp.withCredentials;
    } // Introspect to get idx response


    idxResponse = await (0, _introspect.introspect)(authClient, {
      withCredentials,
      version,
      interactionHandle
    });
    enabledFeatures = getEnabledFeatures(idxResponse);
    availableSteps = getAvailableSteps(idxResponse); // Include meta in the transaction response

    meta = metaFromResp;

    if (autoRemediate !== false && (remediators || actions)) {
      var _idxResponse;

      const values = { ...options,
        stateHandle: idxResponse.rawIdxState.stateHandle
      }; // Can we handle the remediations?

      const {
        idxResponse: idxResponseFromResp,
        nextStep: nextStepFromResp,
        terminal,
        canceled,
        messages: messagesFromResp
      } = await (0, _remediate.remediate)(idxResponse, values, {
        remediators,
        actions,
        flow,
        step
      });
      idxResponse = idxResponseFromResp || idxResponse; // Track fields from remediation response

      nextStep = nextStepFromResp;
      messages = messagesFromResp; // Save intermediate idx response in storage to reduce introspect call

      if (nextStep) {
        authClient.transactionManager.saveIdxResponse(idxResponse.rawIdxState);
        availableSteps = getAvailableSteps(idxResponse);
      }

      if (terminal) {
        status = _types.IdxStatus.TERMINAL;
        shouldClearTransaction = true;
        clearSharedStorage = false; // transaction may be continued in another tab
      }

      if (canceled) {
        status = _types.IdxStatus.CANCELED;
        shouldClearTransaction = true;
      } else if ((_idxResponse = idxResponse) !== null && _idxResponse !== void 0 && _idxResponse.interactionCode) {
        interactionCode = idxResponse.interactionCode;

        if (exchangeCodeForTokens === false) {
          status = _types.IdxStatus.SUCCESS;
          shouldClearTransaction = false;
        } else {
          // exchange the interaction code for tokens
          const {
            clientId,
            codeVerifier,
            ignoreSignature,
            redirectUri,
            urls,
            scopes
          } = metaFromResp;
          tokens = await authClient.token.exchangeCodeForTokens({
            interactionCode,
            clientId,
            codeVerifier,
            ignoreSignature,
            redirectUri,
            scopes
          }, urls);
          status = _types.IdxStatus.SUCCESS;
          shouldClearTransaction = true;
        }
      }
    }
  } catch (err) {
    // current version of idx-js will throw/reject IDX responses. Handle these differently than regular errors
    if ((0, _idxJs.isIdxResponse)(err)) {
      error = err;
      status = _types.IdxStatus.FAILURE;
      shouldClearTransaction = true;
    } else {
      // error is not an IDX response, throw it like a regular error
      throw err;
    }
  }

  if (shouldClearTransaction) {
    authClient.transactionManager.clear({
      clearSharedStorage
    });
  } // from idx-js, used by the widget


  const {
    actions,
    context,
    neededToProceed,
    proceed,
    rawIdxState
  } = idxResponse || {};
  return {
    status,
    ...(meta && {
      meta
    }),
    ...(enabledFeatures && {
      enabledFeatures
    }),
    ...(availableSteps && {
      availableSteps
    }),
    ...(tokens && {
      tokens: tokens.tokens
    }),
    ...(nextStep && {
      nextStep
    }),
    ...(messages && {
      messages
    }),
    ...(error && {
      error
    }),
    interactionCode,
    // if options.exchangeCodeForTokens is false
    // from idx-js
    actions,
    context,
    neededToProceed,
    proceed,
    rawIdxState
  };
}
//# sourceMappingURL=run.js.map