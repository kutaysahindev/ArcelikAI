"use strict";

var _Object$keys = require("@babel/runtime-corejs3/core-js-stable/object/keys");

var _Object$getOwnPropertySymbols = require("@babel/runtime-corejs3/core-js-stable/object/get-own-property-symbols");

var _filterInstanceProperty = require("@babel/runtime-corejs3/core-js-stable/instance/filter");

var _Object$getOwnPropertyDescriptor = require("@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptor");

var _forEachInstanceProperty = require("@babel/runtime-corejs3/core-js-stable/instance/for-each");

var _Object$getOwnPropertyDescriptors = require("@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptors");

var _Object$defineProperties = require("@babel/runtime-corejs3/core-js-stable/object/define-properties");

var _Object$defineProperty = require("@babel/runtime-corejs3/core-js-stable/object/define-property");

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

require("core-js/modules/es.function.name.js");

var _regenerator = _interopRequireDefault(require("@babel/runtime-corejs3/regenerator"));

var _stringify = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/json/stringify"));

var _promise = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/promise"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/defineProperty"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/asyncToGenerator"));

var _client = require("../client");

var _actionParser = require("./actionParser");

var _makeIdxState = _interopRequireDefault(require("./makeIdxState"));

function ownKeys(object, enumerableOnly) { var keys = _Object$keys(object); if (_Object$getOwnPropertySymbols) { var symbols = _Object$getOwnPropertySymbols(object); if (enumerableOnly) symbols = _filterInstanceProperty(symbols).call(symbols, function (sym) { return _Object$getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { var _context2; _forEachInstanceProperty(_context2 = ownKeys(Object(source), true)).call(_context2, function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (_Object$getOwnPropertyDescriptors) { _Object$defineProperties(target, _Object$getOwnPropertyDescriptors(source)); } else { var _context3; _forEachInstanceProperty(_context3 = ownKeys(Object(source))).call(_context3, function (key) { _Object$defineProperty(target, key, _Object$getOwnPropertyDescriptor(source, key)); }); } } return target; }

var generateDirectFetch = function generateDirectFetch(_ref) {
  var actionDefinition = _ref.actionDefinition,
      _ref$defaultParamsFor = _ref.defaultParamsForAction,
      defaultParamsForAction = _ref$defaultParamsFor === void 0 ? {} : _ref$defaultParamsFor,
      _ref$immutableParamsF = _ref.immutableParamsForAction,
      immutableParamsForAction = _ref$immutableParamsF === void 0 ? {} : _ref$immutableParamsF,
      toPersist = _ref.toPersist;
  var target = actionDefinition.href;
  return /*#__PURE__*/function () {
    var _ref2 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(params) {
      var headers, body, credentials;
      return _regenerator.default.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              headers = {
                'content-type': 'application/json',
                'accept': actionDefinition.accepts || 'application/ion+json'
              };
              body = (0, _stringify.default)(_objectSpread(_objectSpread(_objectSpread({}, defaultParamsForAction), params), immutableParamsForAction));
              credentials = toPersist && toPersist.withCredentials === false ? 'omit' : 'include';
              return _context.abrupt("return", (0, _client.request)(target, {
                method: actionDefinition.method,
                headers: headers,
                body: body,
                credentials: credentials
              }).then(function (response) {
                var respJson = response.json();

                if (response.ok) {
                  return respJson;
                } else if (response.status === 401 && response.headers.get('WWW-Authenticate') === 'Oktadevicejwt realm="Okta Device"') {
                  // Okta server responds 401 status code with WWW-Authenticate header and new remediation
                  // so that the iOS/MacOS credential SSO extension (Okta Verify) can intercept
                  // the response reaches here when Okta Verify is not installed
                  // we need to return an idx object so that
                  // the SIW can proceed to the next step without showing error
                  return respJson.then(function (err) {
                    var ms = (0, _makeIdxState.default)(err, toPersist); // set to true if flow should be continued without showing any errors

                    ms.stepUp = true;
                    return _promise.default.reject(ms);
                  });
                }

                return respJson.then(function (err) {
                  return _promise.default.reject((0, _makeIdxState.default)(err, toPersist));
                });
              }).then(function (idxResponse) {
                return (0, _makeIdxState.default)(idxResponse, toPersist);
              }));

            case 4:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    return function (_x) {
      return _ref2.apply(this, arguments);
    };
  }();
}; // TODO: Resolve in M2: Either build the final polling solution or remove this code
// const generatePollingFetch = function generatePollingFetch( { actionDefinition, defaultParamsForAction = {}, immutableParamsForAction = {} } ) {
//   // TODO: Discussions ongoing about when/how to terminate polling: OKTA-246581
//   const target = actionDefinition.href;
//   return async function(params) {
//     return fetch(target, {
//       method: actionDefinition.method,
//       headers: {
//         'content-type': actionDefinition.accepts,
//       },
//       body: JSON.stringify({ ...defaultParamsForAction, ...params, ...immutableParamsForAction })
//     })
//       .then( response => response.ok ? response.json() : response.json().then( err => Promise.reject(err)) )
//       .then( idxResponse => makeIdxState(idxResponse) );
//   };
// };


var generateIdxAction = function generateIdxAction(actionDefinition, toPersist) {
  // TODO: leaving this here to see where the polling is EXPECTED to drop into the code, but removing any accidental trigger of incomplete code
  // const generator =  actionDefinition.refresh ? generatePollingFetch : generateDirectFetch;
  var generator = generateDirectFetch;

  var _divideActionParamsBy = (0, _actionParser.divideActionParamsByMutability)(actionDefinition),
      defaultParams = _divideActionParamsBy.defaultParams,
      neededParams = _divideActionParamsBy.neededParams,
      immutableParams = _divideActionParamsBy.immutableParams;

  var action = generator({
    actionDefinition: actionDefinition,
    defaultParamsForAction: defaultParams[actionDefinition.name],
    immutableParamsForAction: immutableParams[actionDefinition.name],
    toPersist: toPersist
  });
  action.neededParams = neededParams;
  return action;
};

var _default = generateIdxAction;
exports.default = _default;